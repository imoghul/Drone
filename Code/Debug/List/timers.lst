###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          19/Aug/2022  15:01:48
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        C:\Users\Ibrahim
#        Moghul\OneDrive\Documents\Programming\Drone\Code\timers.c
#    Command line  =  
#        -f C:\Users\IBRAHI~1\AppData\Local\Temp\EWE4B0.tmp ("C:\Users\Ibrahim
#        Moghul\OneDrive\Documents\Programming\Drone\Code\timers.c" -lC
#        "C:\Users\Ibrahim
#        Moghul\OneDrive\Documents\Programming\Drone\Code\Debug\List" -o
#        "C:\Users\Ibrahim
#        Moghul\OneDrive\Documents\Programming\Drone\Code\Debug\Obj" --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h" -I
#        ./ --core=430X --data_model=small -Ohz --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\Ibrahim
#        Moghul\OneDrive\Documents\Programming\Drone\Code\Debug\List\timers.lst
#    Object file   =  
#        C:\Users\Ibrahim
#        Moghul\OneDrive\Documents\Programming\Drone\Code\Debug\Obj\timers.r43
#
###############################################################################

C:\Users\Ibrahim Moghul\OneDrive\Documents\Programming\Drone\Code\timers.c
      1          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x21a
   \   union <unnamed> _A_PAIE_L
   \                     _A_PAIE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x222
   \   union <unnamed> _A_PBOUT_L
   \                     _A_PBOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x23a
   \   union <unnamed> _A_PBIE_L
   \                     _A_PBIE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x380
   \   union <unnamed> _A_TB0CTL_L
   \                     _A_TB0CTL_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x382
   \   union <unnamed> _A_TB0CCTL0_L
   \                     _A_TB0CCTL0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x384
   \   union <unnamed> _A_TB0CCTL1_L
   \                     _A_TB0CCTL1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x386
   \   union <unnamed> _A_TB0CCTL2_L
   \                     _A_TB0CCTL2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x392
   \   union <unnamed> _A_TB0CCR0_L
   \                     _A_TB0CCR0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x394
   \   union <unnamed> _A_TB0CCR1_L
   \                     _A_TB0CCR1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x396
   \   union <unnamed> _A_TB0CCR2_L
   \                     _A_TB0CCR2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3a0
   \   union <unnamed> _A_TB0EX0_L
   \                     _A_TB0EX0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3ae
   \   union <unnamed> _A_TB0IV_L
   \                     _A_TB0IV_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3c0
   \   union <unnamed> _A_TB1CTL_L
   \                     _A_TB1CTL_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3c2
   \   union <unnamed> _A_TB1CCTL0_L
   \                     _A_TB1CCTL0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3d2
   \   union <unnamed> _A_TB1CCR0_L
   \                     _A_TB1CCR0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3e0
   \   union <unnamed> _A_TB1EX0_L
   \                     _A_TB1EX0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3ee
   \   union <unnamed> _A_TB1IV_L
   \                     _A_TB1IV_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x440
   \   union <unnamed> _A_TB3CTL_L
   \                     _A_TB3CTL_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x444
   \   union <unnamed> _A_TB3CCTL1_L
   \                     _A_TB3CCTL1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x446
   \   union <unnamed> _A_TB3CCTL2_L
   \                     _A_TB3CCTL2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x448
   \   union <unnamed> _A_TB3CCTL3_L
   \                     _A_TB3CCTL3_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x44a
   \   union <unnamed> _A_TB3CCTL4_L
   \                     _A_TB3CCTL4_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x452
   \   union <unnamed> _A_TB3CCR0_L
   \                     _A_TB3CCR0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x454
   \   union <unnamed> _A_TB3CCR1_L
   \                     _A_TB3CCR1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x456
   \   union <unnamed> _A_TB3CCR2_L
   \                     _A_TB3CCR2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x458
   \   union <unnamed> _A_TB3CCR3_L
   \                     _A_TB3CCR3_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x45a
   \   union <unnamed> _A_TB3CCR4_L
   \                     _A_TB3CCR4_L:
   \   000000                DS8 2
      2          #include "timers.h"
      3          #include "ports.h"
      4          #include "macros.h"
      5          #include "wheels.h"
      6          #include "sm.h"
      7          
      8          
      9          extern volatile unsigned char update_display;
     10          extern char receievedFromPC;

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     11          char pingCounter;
   \                     pingCounter:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     12          volatile char pingFlag;
   \                     pingFlag:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     13          volatile unsigned int debouncing1, debouncing2;
   \                     debouncing1:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     debouncing2:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     14          volatile unsigned int debounce_count1, debounce_count2;
   \                     debounce_count1:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     debounce_count2:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     15          volatile unsigned int debounce_thresh1, debounce_thresh2;
   \                     debounce_thresh1:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     debounce_thresh2:
   \   000000                DS8 2
     16          

   \                                 In  segment CODE, align 2
     17          void Init_Timers(void) {
   \                     Init_Timers:
     18              Init_Timer_B0();
   \   000000   ........     CALLA   #Init_Timer_B0
     19              Init_Timer_B1();
   \   000004   ........     CALLA   #Init_Timer_B1
     20              Init_Timer_B3();
   \   000008   ........     BRA     #Init_Timer_B3
     21          }
     22          

   \                                 In  segment CODE, align 2
     23          void Init_Timer_B0(void) {
   \                     Init_Timer_B0:
     24              TB0CTL = TBSSEL__SMCLK; // SMCLK source
   \   000000   B24000028003 MOV.W   #0x200, &0x380
     25              TB0CTL |= TBCLR; // Resets TB0R, clock divider, count direction
   \   000006   A2D28003     BIS.W   #0x4, &0x380
     26              TB0CTL |= MC__CONTINOUS; // Continuous up
   \   00000A   B2D020008003 BIS.W   #0x20, &0x380
     27              TB0CTL |= ID__2; // Divide clock by 2
   \   000010   B2D040008003 BIS.W   #0x40, &0x380
     28          
     29              //TB0CTL = TBSSEL__SMCLK | TBCLR | MC__CONTINOUS | ID__2;
     30          
     31              TB0EX0 = TBIDEX__8; // Divide clock by an additional 8
   \   000016   B2400700A003 MOV.W   #0x7, &0x3a0
     32          
     33              TB0CCR0 = TB0CCR0_INTERVAL; // CCR0
   \   00001C   B240D0079203 MOV.W   #0x7d0, &0x392
     34              TB0CCTL0 |= CCIE; // CCR0 enable interrupt
   \   000022   B2D010008203 BIS.W   #0x10, &0x382
     35          
     36              TB0CCR1 = TB0CCR1_INTERVAL; // CCR1
   \   000028   B24050C39403 MOV.W   #0xc350, &0x394
     37              //TB0CCTL1 |= CCIE; // CCR1 enable interrupt
     38          
     39              TB0CCR2 = TB0CCR2_INTERVAL; // CCR2
   \   00002E   B24050C39603 MOV.W   #0xc350, &0x396
     40              //TB0CCTL2 |= CCIE; // CCR2 enable interrupt
     41          
     42              TB0CTL &= ~TBIE & ~TBIFG; // Disable Overflow Interrupt
   \   000034   B2F0FCFF8003 AND.W   #0xfffc, &0x380
     43              //TB0CTL &= ~TBIFG; // Clear Overflow Interrupt flag
     44          }
   \   00003A   1001         RETA
   \   00003C                REQUIRE _A_TB0CTL_L
   \   00003C                REQUIRE _A_TB0EX0_L
   \   00003C                REQUIRE _A_TB0CCR0_L
   \   00003C                REQUIRE _A_TB0CCTL0_L
   \   00003C                REQUIRE _A_TB0CCR1_L
   \   00003C                REQUIRE _A_TB0CCR2_L
     45          

   \                                 In  segment CODE, align 2
     46          void Init_Timer_B1(void) {
   \                     Init_Timer_B1:
     47              TB1CTL = TBSSEL__SMCLK; // SMCLK source
   \   000000   B2400002C003 MOV.W   #0x200, &0x3c0
     48              TB1CTL |= TBCLR; // Resets TB0R, clock divider, count direction
   \   000006   A2D2C003     BIS.W   #0x4, &0x3c0
     49              TB1CTL |= MC__CONTINOUS; // Continuous up
   \   00000A   B2D02000C003 BIS.W   #0x20, &0x3c0
     50              TB1CTL |= ID__4; // Divide clock by 4
   \   000010   B2D08000C003 BIS.W   #0x80, &0x3c0
     51          
     52              //TB1CTL = TBSSEL__SMCLK | TBCLR | MC__CONTINOUS | ID__4;
     53          
     54              TB1EX0 = TBIDEX__8; // Divide clock by an additional 8
   \   000016   B2400700E003 MOV.W   #0x7, &0x3e0
     55          
     56              TB1CCR0 = TB1CCR0_INTERVAL; // CCR0
   \   00001C   B24050C3D203 MOV.W   #0xc350, &0x3d2
     57              TB1CCTL0 |= CCIE; // CCR0 enable interrupt
   \   000022   B2D01000C203 BIS.W   #0x10, &0x3c2
     58          
     59              //TB1CCR1 = TB1CCR1_INTERVAL; // CCR1
     60              //TB1CCTL1 |= CCIE; // CCR1 enable interrupt
     61          
     62              //TB1CCR2 = TB1CCR2_INTERVAL; // CCR2
     63              //TB1CCTL2 |= CCIE; // CCR2 enable interrupt
     64          
     65              TB1CTL &= ~TBIE & ~TBIFG; // Disable Overflow Interrupt
   \   000028   B2F0FCFFC003 AND.W   #0xfffc, &0x3c0
     66              //TB1CTL &= ~TBIFG; // Clear Overflow Interrupt flag
     67          }
   \   00002E   1001         RETA
   \   000030                REQUIRE _A_TB1CTL_L
   \   000030                REQUIRE _A_TB1EX0_L
   \   000030                REQUIRE _A_TB1CCR0_L
   \   000030                REQUIRE _A_TB1CCTL0_L
     68          

   \                                 In  segment CODE, align 2
     69          void Init_Timer_B3(void) {
   \                     Init_Timer_B3:
     70              TB3CTL = TBSSEL__SMCLK;
   \   000000   B24000024004 MOV.W   #0x200, &0x440
     71              TB3CTL |= MC__UP;
   \   000006   B2D010004004 BIS.W   #0x10, &0x440
     72              TB3CTL |= TBCLR;
   \   00000C   A2D24004     BIS.W   #0x4, &0x440
     73          
     74              //TB3CTL = TBCLR | MC__UP | TBSSEL__SMCLK;
     75          
     76              TB3CCR0 = WHEEL_PERIOD;
   \   000010   B240204E5204 MOV.W   #0x4e20, &0x452
     77          
     78              TB3CCTL1 = OUTMOD_7;
   \   000016   3F40E000     MOV.W   #0xe0, R15
   \   00001A   824F4404     MOV.W   R15, &0x444
     79              RIGHT_FORWARD_SPEED = WHEEL_OFF;
   \   00001E   82435404     MOV.W   #0x0, &0x454
     80          
     81              TB3CCTL2 = OUTMOD_7;
   \   000022   824F4604     MOV.W   R15, &0x446
     82              LEFT_FORWARD_SPEED = WHEEL_OFF;
   \   000026   82435604     MOV.W   #0x0, &0x456
     83          
     84              TB3CCTL3 = OUTMOD_7;
   \   00002A   824F4804     MOV.W   R15, &0x448
     85              RIGHT_REAR_SPEED = WHEEL_OFF;
   \   00002E   82435804     MOV.W   #0x0, &0x458
     86          
     87              TB3CCTL4 = OUTMOD_7;
   \   000032   824F4A04     MOV.W   R15, &0x44a
     88              LEFT_REAR_SPEED = WHEEL_OFF;
   \   000036   82435A04     MOV.W   #0x0, &0x45a
     89          }
   \   00003A   1001         RETA
   \   00003C                REQUIRE _A_TB3CTL_L
   \   00003C                REQUIRE _A_TB3CCR0_L
   \   00003C                REQUIRE _A_TB3CCTL1_L
   \   00003C                REQUIRE _A_TB3CCR1_L
   \   00003C                REQUIRE _A_TB3CCTL2_L
   \   00003C                REQUIRE _A_TB3CCR2_L
   \   00003C                REQUIRE _A_TB3CCTL3_L
   \   00003C                REQUIRE _A_TB3CCR3_L
   \   00003C                REQUIRE _A_TB3CCTL4_L
   \   00003C                REQUIRE _A_TB3CCR4_L
     90          
     91          
     92          //===========================================================================
     93          // Function name: Timer0_B0_ISR
     94          //
     95          // Description: Increments Time_Sequence and update_display
     96          //
     97          // Passed : no variables passed
     98          // Locals: no variables declared
     99          // Returned: no values returned
    100          // Globals: no global values
    101          //
    102          // Author: Ibrahim Moghul
    103          // Date: Feb 2022
    104          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    105          //===========================================================================
    106          #pragma vector = TIMER0_B0_VECTOR

   \                                 In  segment ISR_CODE, align 2
    107          __interrupt void Timer0_B0_ISR(void) {
   \                     Timer0_B0_ISR:
    108              //------------------------------------------------------------------------------
    109              // TimerB0 0 Interrupt handler
    110              //----------------------------------------------------------------------------
    111              TB0CCR0 += TB0CCR0_INTERVAL; // Add Offset to TBCCR0
   \   000000   B250D0079203 ADD.W   #0x7d0, &0x392
    112              //----------------------------------------------------------------------------
    113          }
   \   000006   0013         RETI
   \   000008                REQUIRE _A_TB0CCR0_L
    114          
    115          
    116          //===========================================================================
    117          // Function name: TIMER0_B1_ISR
    118          //
    119          // Description: Timer 1 handles switch debounce, and Timer 2 handles
    120          // LCD blinking
    121          //
    122          // Passed : no variables passed
    123          // Locals: no variables declared
    124          // Returned: no values returned
    125          // Globals: no global values
    126          //
    127          // Author: Ibrahim Moghul
    128          // Date: Feb 2022
    129          // Compiler: Built with IAR Embedded Workbench Version: (7.21.1)
    130          //===========================================================================
    131          #pragma vector=TIMER0_B1_VECTOR

   \                                 In  segment ISR_CODE, align 2
    132          __interrupt void TIMER0_B1_ISR(void) {
   \                     TIMER0_B1_ISR:
   \   000000   0F12         PUSH.W  R15
    133              //----------------------------------------------------------------------------
    134              // TimerB0 1-2, Overflow Interrupt Vector (TBIV) handler
    135              //----------------------------------------------------------------------------
    136              switch(__even_in_range(TB0IV, 14)) {
   \   000002   1F42AE03     MOV.W   &0x3ae, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for TIMER0_B1_ISR>_0`:
   \   000008   343C         JMP     ??TIMER0_B1_ISR_0
   \   00000A   063C         JMP     ??TIMER0_B1_ISR_5
   \   00000C   1C3C         JMP     ??TIMER0_B1_ISR_6
   \   00000E   313C         JMP     ??TIMER0_B1_ISR_0
   \   000010   303C         JMP     ??TIMER0_B1_ISR_0
   \   000012   2F3C         JMP     ??TIMER0_B1_ISR_0
   \   000014   2E3C         JMP     ??TIMER0_B1_ISR_0
   \   000016   2D3C         JMP     ??TIMER0_B1_ISR_0
    137                  case 0:
    138                      break; // No interrupt
    139          
    140                  case 2: // CCR1 not used
    141                      if(debouncing1 == TRUE) debounce_count1++;
   \                     ??TIMER0_B1_ISR_5:
   \   000018   9293....     CMP.W   #0x1, &debouncing1
   \   00001C   0220         JNE     ??TIMER0_B1_ISR_1
   \   00001E   9253....     ADD.W   #0x1, &debounce_count1
    142          
    143                      if (debounce_count1 > debounce_thresh1) {
                             ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
   \                     ??TIMER0_B1_ISR_1:
   \   000022   1F42....     MOV.W   &debounce_thresh1, R15
   \   000026   1F92....     CMP.W   &debounce_count1, R15
   \   00002A   092C         JC      ??TIMER0_B1_ISR_2
    144                          debounce_count1 = 0;
   \   00002C   8243....     MOV.W   #0x0, &debounce_count1
    145                          debouncing1 = FALSE;
   \   000030   8243....     MOV.W   #0x0, &debouncing1
    146                          P4IE |= SW1;
   \   000034   E2D33B02     BIS.B   #0x2, &0x23b
    147                          TB0CCTL1 &= ~CCIE;
   \   000038   B2C010008403 BIC.W   #0x10, &0x384
    148                      }
    149          
    150                      TB0CCR1 += TB0CCR1_INTERVAL; // Add Offset to TBCCR1
   \                     ??TIMER0_B1_ISR_2:
   \   00003E   B25050C39403 ADD.W   #0xc350, &0x394
    151          
    152                      break;
   \   000044   163C         JMP     ??TIMER0_B1_ISR_0
    153          
    154                  case 4: // CCR2 not used
    155                      if(debouncing2 == TRUE) debounce_count2++;
   \                     ??TIMER0_B1_ISR_6:
   \   000046   9293....     CMP.W   #0x1, &debouncing2
   \   00004A   0220         JNE     ??TIMER0_B1_ISR_3
   \   00004C   9253....     ADD.W   #0x1, &debounce_count2
    156          
    157                      if (debounce_count2 > debounce_thresh2) {
                             ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is undefined
          in this statement
   \                     ??TIMER0_B1_ISR_3:
   \   000050   1F42....     MOV.W   &debounce_thresh2, R15
   \   000054   1F92....     CMP.W   &debounce_count2, R15
   \   000058   092C         JC      ??TIMER0_B1_ISR_4
    158                          debounce_count2 = 0;
   \   00005A   8243....     MOV.W   #0x0, &debounce_count2
    159                          debouncing2 = FALSE;
   \   00005E   8243....     MOV.W   #0x0, &debouncing2
    160                          P2IE |= SW2;
   \   000062   F2D21B02     BIS.B   #0x8, &0x21b
    161                          TB0CCTL2 &= ~CCIE;
   \   000066   B2C010008603 BIC.W   #0x10, &0x386
    162                      }
    163          
    164                      TB0CCR2 += TB0CCR2_INTERVAL; // Add Offset to TBCCR2
   \                     ??TIMER0_B1_ISR_4:
   \   00006C   B25050C39603 ADD.W   #0xc350, &0x396
    165          
    166                      break;
    167          
    168                  case 14: // overflow
    169          
    170                      break;
    171          
    172                  default:
    173                      break;
    174              }
    175          
    176              //----------------------------------------------------------------------------
    177          }
   \                     ??TIMER0_B1_ISR_0:
   \   000072   3F41         POP.W   R15
   \   000074   0013         RETI
   \   000076                REQUIRE _A_PBIE_L
   \   000076                REQUIRE _A_TB0CCTL1_L
   \   000076                REQUIRE _A_TB0CCR1_L
   \   000076                REQUIRE _A_PAIE_L
   \   000076                REQUIRE _A_TB0CCTL2_L
   \   000076                REQUIRE _A_TB0CCR2_L
   \   000076                REQUIRE _A_TB0IV_L
    178          
    179          #pragma vector = TIMER1_B0_VECTOR

   \                                 In  segment ISR_CODE, align 2
    180          __interrupt void Timer1_B0_ISR(void) {
   \                     Timer1_B0_ISR:
   \   000000   1F15         PUSHM.W #0x2, R15
    181              //------------------------------------------------------------------------------
    182              // TimerB0 0 Interrupt handler
    183              //----------------------------------------------------------------------------
    184              P3OUT |= IOT_EN_CPU;
   \   000002   F2D080002202 BIS.B   #0x80, &0x222
    185          
    186              if(pingCounter++ >= PING_COUNT_MAX) {
   \   000008   5E42....     MOV.B   &pingCounter, R14
   \   00000C   4F4E         MOV.B   R14, R15
   \   00000E   5F53         ADD.B   #0x1, R15
   \   000010   7E900A00     CMP.B   #0xa, R14
   \   000014   0328         JNC     ??Timer1_B0_ISR_0
    187                  pingCounter = 0;
   \   000016   4F43         MOV.B   #0x0, R15
    188                  pingFlag = 1;
   \   000018   D243....     MOV.B   #0x1, &pingFlag
   \                     ??Timer1_B0_ISR_0:
   \   00001C   C24F....     MOV.B   R15, &pingCounter
    189              }
    190          
    191              update_display = 1;
   \   000020   D243....     MOV.B   #0x1, &update_display
    192              TB1CCR0 += TB1CCR0_INTERVAL;
   \   000024   B25050C3D203 ADD.W   #0xc350, &0x3d2
    193              //----------------------------------------------------------------------------
    194          }
   \   00002A   1E17         POPM.W  #0x2, R15
   \   00002C   0013         RETI
   \   00002E                REQUIRE _A_PBOUT_L
   \   00002E                REQUIRE _A_TB1CCR0_L
    195          
    196          #pragma vector=TIMER1_B1_VECTOR

   \                                 In  segment ISR_CODE, align 2
    197          __interrupt void TIMER1_B1_ISR(void) {
   \                     TIMER1_B1_ISR:
   \   000000   0F12         PUSH.W  R15
    198              //----------------------------------------------------------------------------
    199              // TimerB0 1-2, Overflow Interrupt Vector (TBIV) handler
    200              //----------------------------------------------------------------------------
    201              switch(__even_in_range(TB1IV, 14)) {
   \   000002   1F42EE03     MOV.W   &0x3ee, R15
    202                  case 0:
    203                      break; // No interrupt
    204          
    205                  case 2: // Left Motor
    206          
    207                      break;
    208          
    209                  case 4: // Right Motor
    210          
    211                      break;
    212          
    213                  case 14: // overflow
    214          
    215                      break;
    216          
    217                  default:
    218                      break;
    219              }
    220          
    221              //----------------------------------------------------------------------------
    222          }
   \   000006   3F41         POP.W   R15
   \   000008   0013         RETI
   \   00000A                REQUIRE _A_TB1IV_L

   \                                 In  segment INTVEC, offset 0x50, root
   \                     `??TIMER1_B1_ISR::??INTVEC 80`:
   \   000050   ....         DC16    TIMER1_B1_ISR

   \                                 In  segment INTVEC, offset 0x52, root
   \                     `??Timer1_B0_ISR::??INTVEC 82`:
   \   000052   ....         DC16    Timer1_B0_ISR

   \                                 In  segment INTVEC, offset 0x54, root
   \                     `??TIMER0_B1_ISR::??INTVEC 84`:
   \   000054   ....         DC16    TIMER0_B1_ISR

   \                                 In  segment INTVEC, offset 0x56, root
   \                     `??Timer0_B0_ISR::??INTVEC 86`:
   \   000056   ....         DC16    Timer0_B0_ISR

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   Init_Timer_B0
      4   Init_Timer_B1
      4   Init_Timer_B3
      4   Init_Timers
        4   -> Init_Timer_B0
        4   -> Init_Timer_B1
        0   -> Init_Timer_B3
      6   TIMER0_B1_ISR
      6   TIMER1_B1_ISR
      4   Timer0_B0_ISR
      8   Timer1_B0_ISR


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      60  Init_Timer_B0
      48  Init_Timer_B1
      60  Init_Timer_B3
      12  Init_Timers
     118  TIMER0_B1_ISR
       2  TIMER0_B1_ISR::??INTVEC 84
      10  TIMER1_B1_ISR
       2  TIMER1_B1_ISR::??INTVEC 80
       8  Timer0_B0_ISR
       2  Timer0_B0_ISR::??INTVEC 86
      46  Timer1_B0_ISR
       2  Timer1_B0_ISR::??INTVEC 82
       2  _A_PAIE_L
       2  _A_PBIE_L
       2  _A_PBOUT_L
       2  _A_TB0CCR0_L
       2  _A_TB0CCR1_L
       2  _A_TB0CCR2_L
       2  _A_TB0CCTL0_L
       2  _A_TB0CCTL1_L
       2  _A_TB0CCTL2_L
       2  _A_TB0CTL_L
       2  _A_TB0EX0_L
       2  _A_TB0IV_L
       2  _A_TB1CCR0_L
       2  _A_TB1CCTL0_L
       2  _A_TB1CTL_L
       2  _A_TB1EX0_L
       2  _A_TB1IV_L
       2  _A_TB3CCR0_L
       2  _A_TB3CCR1_L
       2  _A_TB3CCR2_L
       2  _A_TB3CCR3_L
       2  _A_TB3CCR4_L
       2  _A_TB3CCTL1_L
       2  _A_TB3CCTL2_L
       2  _A_TB3CCTL3_L
       2  _A_TB3CCTL4_L
       2  _A_TB3CTL_L
       2  debounce_count1
       2  debounce_count2
       2  debounce_thresh1
       2  debounce_thresh2
       2  debouncing1
       2  debouncing2
       1  pingCounter
       1  pingFlag

 
 180 bytes in segment CODE
  54 bytes in segment DATA16_AN
  14 bytes in segment DATA16_Z
   8 bytes in segment INTVEC
 182 bytes in segment ISR_CODE
 
 362 bytes of CODE  memory
   0 bytes of CONST memory (+  8 bytes shared)
  14 bytes of DATA  memory (+ 54 bytes shared)

Errors: none
Warnings: 2
